|-- batuque-teste (troca de audios).py
|-- batuque.py
|-- interface.py
|-- LICENSE
|-- README.md
|-- requirements.txt
|-- rodar_batuque.py
|-- screens/
  |-- menu_resolucao.py
  |-- menu_volume.py
  |-- telaLogin.py
  |-- telaRegistro.py
|-- src/
  |-- Images/
    |-- Bumbo.png
    |-- Bumbou.png
    |-- Caixa.png
    |-- Caixa2.png
    |-- Chimbal.png
    |-- Crash.png
    |-- tela inicial/
      |-- configuracoes_button.svg
      |-- drum_no_copyright.mp3
      |-- imagem_de_fundo.png
      |-- login_button.svg
      |-- logo.png
      |-- register_button.svg
      |-- return_button.png
      |-- sair_button.svg
      |-- tocar_button.svg
  |-- sounds/
    |-- Bumbo/
      |-- Bumbo v2.wav
      |-- Bumbo v3.wav
      |-- Bumbo.wav
    |-- Caixa/
      |-- Caixa v2.wav
      |-- Caixa v3.wav
      |-- Caixa.mp3
    |-- Caixa2/
      |-- Caixa2 v2.wav
      |-- Caixa2 v3.wav
      |-- Caixa2.mp3
    |-- Chimbal/
      |-- Chimbal v2.wav
      |-- Chimbal v3.wav
      |-- Chimbal.mp3
    |-- Crash/
      |-- Chash v3.wav
      |-- Crash v2.wav
      |-- Crash.mp3
    |-- Tutorial 1.wav
    |-- Tutorial 2.wav
|-- teste_cor_alvo_instrumentos.py


File contents:

|-- batuque-teste (troca de audios).py
  Content:
    import sys
    import numpy as np
    import cv2
    import time
    from pygame import mixer
    
    # Configurações de cor para detecção
    h_low, h_high = 146, 172
    s_low, s_high = 116, 255
    v_low, v_high = 123, 255
    pinkLower = (h_low, s_low, v_low)
    pinkUpper = (h_high, s_high, v_high)
    
    def run_batuque():
        width = 1920
        height = 1080
    
        last_played_time = [0, 0, 0, 0, 0]
        cooldown = 0.5  # Tempo em segundos entre toques
    
        # Estado para verificar se o som já foi tocado
        sound_played = [False, False, False, False, False]
    
        mixer.init()
        drum_sounds = [
            mixer.Sound('src/sounds/Chimbal/Chimbal.mp3'),
            mixer.Sound('src/sounds/Caixa/Caixa.mp3'),
            mixer.Sound('src/sounds/Bumbo/Bumbo.wav'),
            mixer.Sound('src/sounds/Crash/Crash.mp3'),
            mixer.Sound('src/sounds/Caixa2/Caixa2.mp3')
        ]
    
        def state_machine(sound_index):
            current_time = time.time()
            if current_time - last_played_time[sound_index] >= cooldown:
                drum_sounds[sound_index].play()
                last_played_time[sound_index] = current_time
                sound_played[sound_index] = True
    
        def calc_mask(frame, lower, upper):
            hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
            return cv2.inRange(hsv, lower, upper)
    
        def ROI_analysis(roi, sound_index, lower, upper, min_value=30):
            mask = calc_mask(roi, lower, upper)
            summation = np.sum(mask)
            
            # Checar se o objeto está na hit box
            if summation >= min_value:
                if not sound_played[sound_index]:
                    state_machine(sound_index)
            else:
                sound_played[sound_index] = False
    
            return mask
    
        camera = cv2.VideoCapture(0)
        camera.set(cv2.CAP_PROP_FRAME_WIDTH, width)
        camera.set(cv2.CAP_PROP_FRAME_HEIGHT, height)
    
        instruments = ['Chimbal.png', 'Caixa.png', 'Bumbo.png', 'Crash.png', 'Caixa2.png']
        instrument_images = [cv2.imread(f'./src/Images/{img}', cv2.IMREAD_UNCHANGED) for img in instruments]
        instrument_images[1] = cv2.resize(instrument_images[1], (200, 150), interpolation=cv2.INTER_CUBIC)  # Redimensionar Caixa
        instrument_images[4] = cv2.resize(instrument_images[4], (200, 150), interpolation=cv2.INTER_CUBIC)  # Redimensionar Caixa espelhada
    
        H, W = 720, 1280
        centers = [
            (W * 1 // 8, H * 4 // 8),  # Chimbal
            (W * 6 // 8, H * 6 // 8),  # Caixa
            (W * 4 // 8, H * 7 // 8),  # Bumbo
            (W * 7 // 8, H * 4 // 8),  # Crash
            (W * 2 // 8, H * 6 // 8)   # Caixa espelhada
        ]
        sizes = [(200, 200), (200, 150), (200, 200), (200, 200), (200, 150)]
    
        ROIs = [(center[0] - size[0] // 2, center[1] - size[1] // 2, center[0] + size[0] // 2, center[1] + size[1] // 2) for center, size in zip(centers, sizes)]
    
        while True:
            ret, frame = camera.read()
            if not ret:
                break
            frame = cv2.flip(frame, 1)
            cv2.putText(frame, 'Projeto: Batuque', (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 1, (20, 20, 20), 2)
    
            for i, (top_x, top_y, bottom_x, bottom_y) in enumerate(ROIs):
                roi = frame[top_y:bottom_y, top_x:bottom_x]
                mask = ROI_analysis(roi, i, pinkLower, pinkUpper)
    
                overlay = instrument_images[i]
                overlay_resized = cv2.resize(overlay, (roi.shape[1], roi.shape[0]))
    
                if overlay_resized.shape[2] == 4:
                    b, g, r, a = cv2.split(overlay_resized)
                    overlay_rgb = cv2.merge((b, g, r))
    
                    alpha_mask = a / 255.0 * 0.5
                    alpha_inv = 1.0 - alpha_mask
    
                    for c in range(0, 3):
                        frame[top_y:bottom_y, top_x:bottom_x, c] = (alpha_mask * overlay_rgb[:, :, c] +
                                                                    alpha_inv * frame[top_y:bottom_y, top_x:bottom_x, c])
                else:
                    frame[top_y:bottom_y, top_x:bottom_x] = cv2.addWeighted(overlay_resized, 0.5, roi, 0.5, 0)
    
            cv2.imshow('Batuque Project', frame)
    
            if cv2.waitKey(1) & 0xFF == ord('q'):
                break
    
        camera.release()
        cv2.destroyAllWindows()
        sys.exit()
|-- batuque.py
  Content:
    import sys
    import numpy as np
    import cv2
    import time
    from pygame import mixer
    
    # Configurações de cor para detecção
    h_low, h_high = 146, 172
    s_low, s_high = 116, 255
    v_low, v_high = 123, 255
    pinkLower = (h_low, s_low, v_low)
    pinkUpper = (h_high, s_high, v_high)
    
    # Configurações da música
    mixer.init()
    mixer.music.load('src/sounds/Tutorial 2.wav')
    
    def init_mixer_and_play_music(music):
        mixer.init()
        mixer.music.load(music)
        mixer.music.play()
        print("Música iniciada:", music)
    
    # Tutorial (iniciante) - Tempo das batidas (em segundos)
    
    #Bumbo_times = [2.75, 3.10, 4.25, 4.55, 5.65, 6, 7.1, 7.5, 8.6, 9, 10.10, 10.47, 11.6, 12, 13.10, 13.45]
    #Caixa_times = [3.45, 4.9, 6.35, 7.9, 9.37, 10.87, 12.30, 13.80]
    
    # Tutorial (intermediario e avançado) - comente o bumbo para intermediario.
    
    Bumbo_times = [2.6, 3, 4.1, 4.4, 5.6, 5.9, 7, 7.4, 8.5, 8.9, 10, 10.35, 11.4, 11.8, 12.7, 13.1, 14.3, 14.7, 15.8, 16.2, 17.3, 17.65, 18.75, 19.1, 20.2, 20.6, 21.7, 22.1, 23.1, 23.5, 24.55, 24.95, 26.05, 26.4, 27.45, 27.85, 28.95, 29.3, 30.35, 30.65, 31.87, 32.25, 33.35, 33.75, 34.85, 35.25]
    Caixa_times = [3.35, 4.8, 6.3, 7.8, 9.2, 10.7, 12.1, 13.6, 15.1, 16.5, 18.05, 19.5, 20.95, 22.4, 23.8, 25.3, 26.7, 28.2, 29.65, 31.15, 32.65, 34.1, 35.55]
    Chimbal_times = [2.7, 3.0, 3.4, 3.8, 4.2, 4.6, 5.0, 5.4, 5.8, 6.2, 6.6, 7.0, 7.4, 7.8, 8.2, 8.6, 9.0, 9.4, 9.8, 10.2, 10.6, 11.0, 11.4, 11.8, 12.2, 12.6, 13.0, 13.4, 13.8, 14.2, 14.6, 15.0, 15.4, 15.8, 16.2, 16.6, 17.0, 17.4, 17.8, 18.2, 18.6, 19.0, 19.4, 19.8, 20.2, 20.6, 21.0, 21.4, 21.8, 22.2, 22.6, 23.0, 23.4, 23.8, 24.2, 24.6, 25.0, 25.4, 25.8, 26.2, 26.6, 27.0, 27.4, 27.8, 28.2, 28.6, 29.0, 29.4, 29.8, 30.2, 30.6, 31.0, 31.4, 31.8, 32.2, 32.6, 33.0, 33.4, 33.8, 34.2, 34.6, 35.0]
    
    def run_batuque():
        width = 1920
        height = 1080
    
        last_played_time = [0, 0, 0, 0, 0]
        cooldown = 0.5  # Tempo em segundos entre toques
    
        # Estado para verificar se o som já foi tocado
        sound_played = [False, False, False, False, False]
    
        drum_sounds = [
            mixer.Sound('src/sounds/Chimbal/Chimbal.mp3'),
            mixer.Sound('src/sounds/Caixa/Caixa.mp3'),
            mixer.Sound('src/sounds/Bumbo/Bumbo.wav'),
            mixer.Sound('src/sounds/Crash/Crash.mp3'),
            mixer.Sound('src/sounds/Caixa2/Caixa2.mp3')
        ]
    
        def state_machine(sound_index):
            current_time = time.time()
            if current_time - last_played_time[sound_index] >= cooldown:
                drum_sounds[sound_index].play()
                last_played_time[sound_index] = current_time
                sound_played[sound_index] = True
    
        def calc_mask(frame, lower, upper):
            hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
            return cv2.inRange(hsv, lower, upper)
    
        def ROI_analysis(roi, sound_index, lower, upper, min_value=30):
            mask = calc_mask(roi, lower, upper)
            summation = np.sum(mask)
            
            # Checar se o objeto está na hit box
            if summation >= min_value:
                if not sound_played[sound_index]:
                    state_machine(sound_index)
            else:
                sound_played[sound_index] = False
    
            return mask
    
        camera = cv2.VideoCapture(0)
        camera.set(cv2.CAP_PROP_FRAME_WIDTH, width)
        camera.set(cv2.CAP_PROP_FRAME_HEIGHT, height)
    
        if not camera.isOpened():
            print("Erro ao abrir a câmera")
            sys.exit()
    
        # Adiciona as imagens dos instrumentos
        instruments = ['Chimbal.png', 'Caixa.png', 'Bumbo.png', 'Crash.png', 'Caixa2.png']
        instrument_images = [cv2.imread(f'./src/Images/{img}', cv2.IMREAD_UNCHANGED) for img in instruments]
        instrument_images[1] = cv2.resize(instrument_images[1], (200, 150), interpolation=cv2.INTER_CUBIC)  # Redimensionar Caixa
        instrument_images[4] = cv2.resize(instrument_images[4], (200, 150), interpolation=cv2.INTER_CUBIC)  # Redimensionar Caixa espelhada
    
        H, W = 720, 1280
        centers = [
            (W * 1 // 8, H * 4 // 8),  # Chimbal
            (W * 6 // 8, H * 6 // 8),  # Caixa
            (W * 4 // 8, H * 7 // 8),  # Bumbo
            (W * 7 // 8, H * 4 // 8),  # Crash
            (W * 2 // 8, H * 6 // 8)   # Caixa espelhada
        ]
        sizes = [(200, 200), (200, 150), (200, 200), (200, 200), (200, 150)]
    
        ROIs = [(center[0] - size[0] // 2, center[1] - size[1] // 2, center[0] + size[0] // 2, center[1] + size[1] // 2) for center, size in zip(centers, sizes)]
    
        # Inicia a música assim que a tela carrega
        init_mixer_and_play_music('src/sounds/Tutorial 2.wav')
    
        start_time = time.time()
    
        while True:
            ret, frame = camera.read()
            if not ret:
                print("Erro ao capturar imagem da câmera")
                break
            frame = cv2.flip(frame, 1)
            cv2.putText(frame, 'Projeto: Batuque', (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 1, (20, 20, 20), 2)
            current_time = time.time() - start_time
    
            # Desenhar as imagens dos instrumentos nas ROIs
            for i, (top_x, top_y, bottom_x, bottom_y) in enumerate(ROIs):
                roi = frame[top_y:bottom_y, top_x:bottom_x]
                mask = ROI_analysis(roi, i, pinkLower, pinkUpper)
    
            # Desenhar as esferas roxas preenchidas que expandem com o ritmo da música
            for beat_time in Bumbo_times:
                if abs(current_time - beat_time) < 0.1:
                    # Esfera para o Bumbo
                    center_x, center_y = centers[2]  # Bumbo
                    radius = int(50 + 50 * (1 - abs(current_time - beat_time) / 0.1))  # Esfera expande e contrai
                    cv2.circle(frame, (center_x, center_y), radius, (255, 0, 255), -1)  # Esfera roxa preenchida
    
            for beat_time in Caixa_times:
                if abs(current_time - beat_time) < 0.1:
                    # Esfera para a caixa
                    center_x, center_y = centers[1]  # Caixa
                    radius = int(50 + 50 * (1 - abs(current_time - beat_time) / 0.1))  # Esfera expande e contrai
                    cv2.circle(frame, (center_x, center_y), radius, (255, 0, 255), -1)  # Esfera roxa preenchida
    
            for beat_time in Chimbal_times:
                if abs(current_time - beat_time) < 0.1:  # Corrigido de < 0.0 para < 0.1
                    # Esfera para o chimbal
                    center_x, center_y = centers[0]  # Chimbal
                    radius = int(50 + 50 * (1 - abs(current_time - beat_time) / 0.1))  # Esfera expande e contrai
                    cv2.circle(frame, (center_x, center_y), radius, (255, 0, 255), -1)  # Esfera roxa preenchida
    
            # Colocar as imagens dos instrumentos para sobrepor as esferas
            for i, (top_x, top_y, bottom_x, bottom_y) in enumerate(ROIs):
                roi = frame[top_y:bottom_y, top_x:bottom_x]
                overlay = instrument_images[i]
                overlay_resized = cv2.resize(overlay, (roi.shape[1], roi.shape[0]))
    
                if overlay_resized.shape[2] == 4:
                    b, g, r, a = cv2.split(overlay_resized)
                    overlay_rgb = cv2.merge((b, g, r))
    
                    alpha_mask = a / 255.0 * 0.5
                    alpha_inv = 1.0 - alpha_mask
    
                    for c in range(0, 3):
                        frame[top_y:bottom_y, top_x:bottom_x, c] = (alpha_mask * overlay_rgb[:, :, c] +
                                                                    alpha_inv * frame[top_y:bottom_y, top_x:bottom_x, c])
                else:
                    frame[top_y:bottom_y, top_x:bottom_x] = cv2.addWeighted(overlay_resized, 0.5, roi, 0.5, 0)
    
            cv2.imshow('Batuque Project', frame)
    
            if cv2.waitKey(1) & 0xFF == ord('q'):
                break
    
        camera.release()
       
|-- interface.py
  Content:
    import time
    import pygame
    import sys
    from itertools import cycle
    from pygame.locals import *
    import cv2
    from batuque import run_batuque
    import screens.telaLogin as telaLogin
    import screens.telaRegistro as telaRegistro
    import screens.menu_volume as menu_volume
    import screens.menu_resolucao as menu_resolucao
    
    pygame.init()
    
    # Definir as dimensões da janela
    largura = pygame.display.Info().current_w
    altura = pygame.display.Info().current_h
    tela = pygame.display.set_mode((largura, altura), pygame.SCALED)
    
    # Carregar imagens
    background_image = pygame.image.load("src/Images/tela inicial/imagem_de_fundo.png")
    logo_image = pygame.image.load("src/Images/tela inicial/logo.png")
    button_play_image = pygame.image.load("src/Images/tela inicial/tocar_button.svg")
    button_settings_image = pygame.image.load("src/Images/tela inicial/configuracoes_button.svg")
    button_exit_image = pygame.image.load("src/Images/tela inicial/sair_button.svg")
    button_login_image = pygame.image.load("src/Images/tela inicial/login_button.svg")
    button_registrar_image = pygame.image.load("src/Images/tela inicial/register_button.svg")
    
    # Carregar música
    pygame.mixer.music.load("src/Images/tela inicial/drum_no_copyright.mp3")
    pygame.mixer.music.set_volume(0.2)
    
    # Definir cores
    PRETO = (0, 0, 0)
    BRANCO = (255, 255, 255)
    
    # Definir fonte para a mensagem de boas-vindas
    fonte = pygame.font.Font(None, 145)
    mensagem_boas_vindas = fonte.render("Sinta o som do batuque!", True, BRANCO)
    
    def plot_tela_inicial():
        """Desenha a tela inicial do jogo."""
        tela.blit(background_image, (0, 0))
        tela.blit(button_play_image, (largura // 2 - button_play_image.get_width() // 2, altura - button_play_image.get_height() - 225))
        tela.blit(button_settings_image, (largura // 2 - button_settings_image.get_width() // 2, altura - button_settings_image.get_height() - 150))
        tela.blit(button_exit_image, (largura // 2 - button_exit_image.get_width() // 2, altura - button_exit_image.get_height() - 75))
        tela.blit(mensagem_boas_vindas, (largura // 2 - mensagem_boas_vindas.get_width() // 2, altura // 8))
        tela.blit(button_login_image, (largura // 2 - button_login_image.get_width() // 2, altura - button_login_image.get_height() - 375))
        tela.blit(button_registrar_image, (largura // 2 - button_registrar_image.get_width() // 2, altura - button_registrar_image.get_height() - 300))
        pygame.display.flip()
    
    def loading_screen(loading_progress):
        """Desenha a tela de carregamento com a barra de progresso."""
        tela.fill(PRETO)
        tela.blit(logo_image, (largura // 2 - logo_image.get_width() // 2, altura // 2 - logo_image.get_height() // 2))
        pygame.draw.rect(tela, BRANCO, (100, altura - 50, loading_progress * (largura - 200), 20))
        pygame.display.flip()
    
    def tocar(screen):
        """Inicia a tela do jogo e exibe o vídeo com opções de menu."""
        pygame.mixer.music.stop()  # Parar a música antes de iniciar
        tempo_carregamento = 4
        tempo_inicial = time.time()
    
        # Tela de carregamento
        while True:
            tempo_atual = time.time()
            tempo_decorrido = tempo_atual - tempo_inicial
            loading_progress = min(tempo_decorrido / tempo_carregamento, 1)  # Garantir que o progresso não exceda 1
            loading_screen(loading_progress)
            if tempo_decorrido >= tempo_carregamento:
                break
    
        pygame.time.wait(2000)
    
        # Iniciar a tela do pygame para o batuque
        clock = pygame.time.Clock()
        frames = cycle(run_batuque())
        menu_aberto = False
        voltar_ao_menu_principal = False
    
        while not voltar_ao_menu_principal:
            for event in pygame.event.get():
                if event.type == QUIT:
                    pygame.quit()
                    return
                elif event.type == KEYDOWN:
                    if event.key == K_ESCAPE:
                        menu_aberto = not menu_aberto
                        if menu_aberto:
                            configuracoes(screen)
                        else:
                            voltar_ao_menu_principal = True
                elif event.type == MOUSEBUTTONDOWN and menu_aberto:
                    mouse_pos = pygame.mouse.get_pos()
                    if 100 <= mouse_pos[0] <= 400 and 400 <= mouse_pos[1] <= 450:
                        menu_aberto = False
                        voltar_ao_menu_principal = True
    
            if not menu_aberto:
                try:
                    frame = next(frames)
                except StopIteration:
                    break
    
                screen.fill(PRETO)
                frame_rotacionado = cv2.rotate(frame, cv2.ROTATE_90_COUNTERCLOCKWISE)
                frame_corrigido = cv2.flip(frame_rotacionado, 0)
                frame_surface = pygame.surfarray.make_surface(cv2.cvtColor(frame_corrigido, cv2.COLOR_BGR2RGB))
    
                imagem_largura, imagem_altura = frame_surface.get_size()
                pos_x = (largura - imagem_largura) // 2
                pos_y = (altura - imagem_altura) // 2
    
                screen.blit(frame_surface, (pos_x, pos_y))
                pygame.display.flip()
                clock.tick(30)
    
            if menu_aberto and pygame.key.get_pressed()[pygame.K_ESCAPE]:
                menu_aberto = False
    
        cv2.VideoCapture(0).release()  # Liberar a câmera
        main()
    
    def sair():
        """Encerra o Pygame e sai do programa."""
        pygame.quit()
        sys.exit()
    
    def configuracoes(screen):
        """Abre o menu de configurações."""
        fonte_titulo = pygame.font.Font(None, 48)
        fonte_opcoes = pygame.font.Font(None, 36)
        titulo = fonte_titulo.render("Configurações", True, BRANCO)
    
        configurando = True
        while configurando:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    sair()
                elif event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_ESCAPE:
                        configurando = False
                        return False
                elif event.type == pygame.MOUSEBUTTONDOWN:
                    mouse_pos = pygame.mouse.get_pos()
                    if 100 <= mouse_pos[0] <= 400 and 200 <= mouse_pos[1] <= 250:
                        resolucao = menu_resolucao.config_resolucoes(screen)
                        if not resolucao:
                            plot_tela_inicial()
                            return False
                        pygame.display.set_mode(resolucao)
                    elif 100 <= mouse_pos[0] <= 400 and 300 <= mouse_pos[1] <= 350:
                        volume = menu_volume.config_volume(screen)
                        if not volume:
                            plot_tela_inicial()
                            return False
                        pygame.mixer.music.set_volume(volume)
                    elif 100 <= mouse_pos[0] <= 400 and 400 <= mouse_pos[1] <= 450:
                        return False
    
            screen.fill(PRETO)
            screen.blit(titulo, (100, 50))
    
            pygame.draw.rect(screen, BRANCO, pygame.Rect(100, 200, 300, 50))
            texto_resolucao = fonte_opcoes.render("Mudar Resolução", True, PRETO)
            screen.blit(texto_resolucao, (150, 210))
    
            pygame.draw.rect(screen, BRANCO, pygame.Rect(100, 300, 300, 50))
            texto_volume = fonte_opcoes.render("Ajustar Volume", True, PRETO)
            screen.blit(texto_volume, (180, 310))
    
            pygame.draw.rect(screen, BRANCO, pygame.Rect(100, 400, 300, 50))
            texto_voltar = fonte_opcoes.render("Menu Principal", True, PRETO)
            screen.blit(texto_voltar, (200, 410))
    
            pygame.display.flip()
    
        return True
    
    def main():
        """Função principal que inicia a tela inicial e gerencia eventos do usuário."""
        plot_tela_inicial()
        pygame.mixer.music.play(-1)  # Loop infinito
    
        running = True
        while running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
                elif event.type == pygame.MOUSEBUTTONDOWN:
                    button_play_rect = button_play_image.get_rect(center=(largura // 2 - button_play_image.get_width() // 2, altura - button_play_image.get_height() - 225))
                    button_settings_rect = button_settings_image.get_rect(center=(largura // 2 - button_settings_image.get_width() // 2, altura - button_settings_image.get_height() - 150))
                    button_exit_rect = button_exit_image.get_rect(center=(largura // 2 - button_exit_image.get_width() // 2, altura - button_exit_image.get_height() - 75))
                    button_login_rect = button_login_image.get_rect(center=(largura // 2 - button_login_image.get_width() // 2, altura - button_login_image.get_height() - 375))
                    button_registrar_rect = button_registrar_image.get_rect(center=(largura // 2 - button_registrar_image.get_width() // 2, altura - button_registrar_image.get_height() - 300))
    
                    if button_play_rect.collidepoint(event.pos):
                        tocar(tela)
                    elif button_settings_rect.collidepoint(event.pos):
                        if not configuracoes(tela):
                            plot_tela_inicial()
                    elif button_login_rect.collidepoint(event.pos):
                        telaLogin.login(tela, altura, largura)
                        main()
                    elif button_registrar_rect.collidepoint(event.pos):
                        telaRegistro.registrar(tela, altura, largura)
                        main()
                    elif button_exit_rect.collidepoint(event.pos):
                        sair()
    
            pygame.display.flip()
    
    # Executar o programa
    if __name__ == "__main__":
        main()
    
    # Encerrar o Pygame
    pygame.quit()
|-- LICENSE
|-- README.md
|-- requirements.txt
|-- rodar_batuque.py
  Content:
    import sys
    from batuque import run_batuque
    
    # Roda run_batuque
    if __name__ == "__main__":
        try:
            run_batuque()
        except Exception as e:
            print(f"Erro ao executar 'run_batuque': {e}")
            sys.exit(1)
|-- screens/
  |-- menu_resolucao.py
    Content:
      import sys
      import pygame
      
      bg_color = (0,0,0)
      txt_color = (255,255,255)
      
      def config_resolucoes(tela):
          # Definir fonte para o título
          fonte_titulo = pygame.font.Font(None, 48)
      
          # Definir fonte para as opções
          fonte_opcoes = pygame.font.Font(None, 36)
      
          # Título da tela de resoluções
          titulo = fonte_titulo.render("Escolha a Resolução", True, txt_color)
      
          # Opções disponíveis de resolução
          opcoes_resolucao = [
              {"texto": "800x600", "resolucao": (800, 600)},
              {"texto": "1024x768", "resolucao": (1024, 768)},
              {"texto": "1280x720", "resolucao": (1280, 720)},
              {"texto": "1440x900", "resolucao": (1440, 900)},
              {"texto": "1920x1080", "resolucao": (1920, 1080)},
              {"texto": "Voltar", "acao": "voltar"}
          ]
      
          # Espaço entre as opções
          espaco = 20
      
          # Loop principal da tela de resoluções
          selecionando_resolucao = True
          while selecionando_resolucao:
              for event in pygame.event.get():
                  if event.type == pygame.QUIT:
                      pygame.quit()
                      sys.exit()
                  elif event.type == pygame.MOUSEBUTTONDOWN:
                      mouse_pos = pygame.mouse.get_pos()
                      # Verificar se o clique foi em uma opção de resolução
                      for opcao in opcoes_resolucao:
                          if opcao.get("resolucao"):
                              y_pos = (opcoes_resolucao.index(opcao) + 1) * (60 + espaco) + 100
                              if mouse_pos[0] > 100 and mouse_pos[0] < 400 and mouse_pos[1] > y_pos and mouse_pos[1] < y_pos + 50:
                                  selecionando_resolucao = False
                                  return opcao["resolucao"]
                      # Verificar se o clique foi no botão de voltar
                      if mouse_pos[0] > 100 and mouse_pos[0] < 400 and mouse_pos[1] > 650 and mouse_pos[1] < 700:
                          return False
      
              tela.fill(bg_color)
              tela.blit(titulo, (100, 50))
      
              # Exibir opções de resolução
              for opcao in opcoes_resolucao:
                  if opcao.get("resolucao"):
                      y_pos = (opcoes_resolucao.index(opcao) + 1) * (60 + espaco) + 100
                      pygame.draw.rect(tela, txt_color, pygame.Rect(100, y_pos, 300, 50))
                      texto_renderizado = fonte_opcoes.render(opcao["texto"], True, bg_color)
                      tela.blit(texto_renderizado, (150, y_pos + 10))
      
              # Exibir botão de voltar
              pygame.draw.rect(tela, txt_color, pygame.Rect(100, 650, 300, 50))
              texto_voltar = fonte_opcoes.render("Voltar", True, bg_color)
              tela.blit(texto_voltar, (200, 660))
      
              pygame.display.flip()
  |-- menu_volume.py
    Content:
      import sys
      import pygame
      
      bg_color = (0,0,0)
      txt_color = (255,255,255)
      
      def config_volume(tela):
          # Definir fonte para o título
          fonte_titulo = pygame.font.Font(None, 48)
      
          # Definir fonte para as opções
          fonte_opcoes = pygame.font.Font(None, 36)
      
          # Título da tela de volume
          titulo = fonte_titulo.render("Ajustar Volume", True, txt_color)
      
          # Opções disponíveis de volume
          opcoes_volume = [
              {"texto": "20% de Volume", "volume": 0.2},
              {"texto": "40% de Volume", "volume": 0.4},
              {"texto": "60% de Volume", "volume": 0.6},
              {"texto": "80% de Volume", "volume": 0.8},
              {"texto": "100% de Volume", "volume": 1.0},
              {"texto": "Voltar", "acao": "voltar"}
          ]
      
          # Espaço entre as opções
          espaco = 20
      
          # Loop principal da tela de volume
          ajustando_volume = True
          while ajustando_volume:
              for event in pygame.event.get():
                  if event.type == pygame.QUIT:
                      pygame.quit()
                      sys.exit()
                  elif event.type == pygame.MOUSEBUTTONDOWN:
                      mouse_pos = pygame.mouse.get_pos()
                      # Ajustar volume de acordo com a opção selecionada
                      for opcao in opcoes_volume:
                          if opcao.get("volume"):
                              y_pos = (opcoes_volume.index(opcao) + 1) * (60 + espaco) + 100
                              if mouse_pos[0] > 100 and mouse_pos[0] < 400 and mouse_pos[1] > y_pos and mouse_pos[1] < y_pos + 50:
                                  ajustando_volume = False
                                  return opcao["volume"]
                      # Verificar se o clique foi no botão de voltar
                      if mouse_pos[0] > 100 and mouse_pos[0] < 400 and mouse_pos[1] > 650 and mouse_pos[1] < 700:
                          return False
      
              tela.fill(bg_color)
              tela.blit(titulo, (100, 50))
      
              # Exibir opções de volume
              for opcao in opcoes_volume:
                  if opcao.get("volume"):
                      y_pos = (opcoes_volume.index(opcao) + 1) * (60 + espaco) + 100
                      pygame.draw.rect(tela, txt_color, pygame.Rect(100, y_pos, 300, 50))
                      texto_renderizado = fonte_opcoes.render(opcao["texto"], True, bg_color)
                      tela.blit(texto_renderizado, (150, y_pos + 10))
      
              # Exibir botão de voltar
              pygame.draw.rect(tela, txt_color, pygame.Rect(100, 650, 300, 50))
              texto_voltar = fonte_opcoes.render("Voltar", True, bg_color)
              tela.blit(texto_voltar, (200, 660))
      
              pygame.display.flip()  |-- telaLogin.py
    Content:
      import pygame
      
      bg_color = (240,248,255)
      txt_color = (0,0,0)
      
      return_image = pygame.image.load("./src/Images/tela inicial/return_button.png")
      
      def login(tela, altura, largura):
          fonte = pygame.font.Font(None, 48)
          
          input_box1 = pygame.Rect(largura // 2 - 200, altura // 1.5 - 225, 400, 50)
          input_box2 = pygame.Rect(largura // 2 - 200, altura // 1.5 - 125, 400, 50)
          button_rect = pygame.Rect(largura // 2 - 200, altura // 1.5 - 25, 400, 50)
          button_return_rect = return_image.get_rect(center=(50, altura - return_image.get_height() - 750))
          
          color_inactive = pygame.Color('lightskyblue3')
          color_active = pygame.Color('dodgerblue2')
          
          color1 = color_inactive
          color2 = color_inactive
      
          active1 = False
          active2 = False
      
          text1 = ''
          text2 = ''
      
          fonte_input = pygame.font.Font(None, 36)
          login = True
      
          while login:
              for event in pygame.event.get():
                  if event.type == pygame.QUIT:
                      pygame.quit()
                      exit()
                  elif event.type == pygame.MOUSEBUTTONDOWN:
                      if input_box1.collidepoint(event.pos):
                          active1 = not active1
                      else:
                          active1 = False
                      if input_box2.collidepoint(event.pos):
                          active2 = not active2
                      else:
                          active2 = False
                      if button_return_rect.collidepoint(event.pos):
                          return False
      
                      color1 = color_active if active1 else color_inactive
                      color2 = color_active if active2 else color_inactive
                  elif event.type == pygame.KEYDOWN:
                      if active1:
                          if event.key == pygame.K_RETURN:
                              active1 = False
                          elif event.key == pygame.K_BACKSPACE:
                              text1 = text1[:-1]
                          else:
                              text1 += event.unicode
                      if active2:
                          if event.key == pygame.K_RETURN:
                              active2 = False
                          elif event.key == pygame.K_BACKSPACE:
                              text2 = text2[:-1]
                          else:
                              text2 += event.unicode
      
              tela.fill(bg_color)
              txt_surface1 = fonte_input.render(text1, True, color1)
              txt_surface2 = fonte_input.render('*' * len(text2), True, color2)  # Exibe asteriscos
      
              width1 = max(400, txt_surface1.get_width() + 10)
              input_box1.w = width1
              width2 = max(400, txt_surface2.get_width() + 10)
              input_box2.w = width2
      
              tela.blit(txt_surface1, (input_box1.x + 5, input_box1.y + 5))
              tela.blit(txt_surface2, (input_box2.x + 5, input_box2.y + 5))
      
              
              pygame.draw.rect(tela, color1, input_box1, 2)
              pygame.draw.rect(tela, color2, input_box2, 2)
              pygame.draw.rect(tela, color_inactive, button_rect)
      
              fonte_h1_login = pygame.font.Font(None, 145)
              mensagem_boas_vindas = fonte_h1_login.render("Login", True, txt_color)
      
              tela.blit(return_image, (50, altura - return_image.get_height() - 750))
              tela.blit(mensagem_boas_vindas, (largura // 2 - mensagem_boas_vindas.get_width() // 2, altura // 8))
              texto_usuario = fonte.render("Usuário:", True, txt_color)
              tela.blit(texto_usuario, (input_box1.x, input_box1.y - 40))
              texto_senha = fonte.render("Senha:", True, txt_color)
              tela.blit(texto_senha, (input_box2.x, input_box2.y - 40))
              tela.blit(fonte.render("Entrar", True, txt_color), (button_rect.x + 150, button_rect.y + 10))
              
              pygame.display.flip()
  |-- telaRegistro.py
    Content:
      import pygame
      
      bg_color = (240,248,255)
      txt_color = (0,0,0)
      
      return_image = pygame.image.load("./src/Images/tela inicial/return_button.png")
      
      def registrar(tela, altura, largura):
          fonte = pygame.font.Font(None, 48)
          
          input_box1 = pygame.Rect(largura // 2 - 200, altura // 1.5 - 225, 400, 50)
          input_box2 = pygame.Rect(largura // 2 - 200, altura // 1.5 - 125, 400, 50)
          input_box3 = pygame.Rect(largura // 2 - 200, altura // 1.5 - 25, 400, 50)  # Caixa de confirmação de senha
          button_rect = pygame.Rect(largura // 2 - 200, altura // 1.5 + 75, 400, 50)
          button_return_rect = return_image.get_rect(center=(50, altura - return_image.get_height() - 750))
          
          color_inactive = pygame.Color('lightskyblue3')
          color_active = pygame.Color('dodgerblue2')
          
          color1 = color_inactive
          color2 = color_inactive
          color3 = color_inactive  # Cor para a caixa de confirmação de senha
          
          active1 = False
          active2 = False
          active3 = False  # Ativo para a caixa de confirmação de senha
          
          text1 = ''
          text2 = ''
          text3 = ''  # Texto para a caixa de confirmação de senha
          
          fonte_input = pygame.font.Font(None, 36)
          registrar = True
          while registrar:
              for event in pygame.event.get():
                  if event.type == pygame.QUIT:
                      pygame.quit()
                      exit()
                  elif event.type == pygame.MOUSEBUTTONDOWN:
                      if input_box1.collidepoint(event.pos):
                          active1 = not active1
                      else:
                          active1 = False
                      if input_box2.collidepoint(event.pos):
                          active2 = not active2
                      else:
                          active2 = False
                      if input_box3.collidepoint(event.pos):  # Verificação para a caixa de confirmação de senha
                          active3 = not active3
                      else:
                          active3 = False
                      if button_return_rect.collidepoint(event.pos):
                          return False
      
                      color1 = color_active if active1 else color_inactive
                      color2 = color_active if active2 else color_inactive
                      color3 = color_active if active3 else color_inactive  # Atualização da cor
                  elif event.type == pygame.KEYDOWN:
                      if active1:
                          if event.key == pygame.K_RETURN:
                              active1 = False
                          elif event.key == pygame.K_BACKSPACE:
                              text1 = text1[:-1]
                          else:
                              text1 += event.unicode
                      if active2:
                          if event.key == pygame.K_RETURN:
                              active2 = False
                          elif event.key == pygame.K_BACKSPACE:
                              text2 = text2[:-1]
                          else:
                              text2 += event.unicode
                      if active3:  # Manipulação de entrada para a caixa de confirmação de senha
                          if event.key == pygame.K_RETURN:
                              active3 = False
                          elif event.key == pygame.K_BACKSPACE:
                              text3 = text3[:-1]
                          else:
                              text3 += event.unicode
              
              tela.fill(bg_color)
              
              txt_surface1 = fonte_input.render(text1, True, color1)
              txt_surface2 = fonte_input.render('*' * len(text2), True, color2)  # Exibe asteriscos
              txt_surface3 = fonte_input.render('*' * len(text3), True, color3)  # Exibe asteriscos para a confirmação de senha
              
              width1 = max(400, txt_surface1.get_width() + 10)
              input_box1.w = width1
              width2 = max(400, txt_surface2.get_width() + 10)
              input_box2.w = width2
              width3 = max(400, txt_surface3.get_width() + 10)  # Largura da caixa de confirmação de senha
              
              input_box3.w = width3
              tela.blit(txt_surface1, (input_box1.x + 5, input_box1.y + 5))
              tela.blit(txt_surface2, (input_box2.x + 5, input_box2.y + 5))
              tela.blit(txt_surface3, (input_box3.x + 5, input_box3.y + 5))  # Blit para a confirmação de senha
              
              pygame.draw.rect(tela, color1, input_box1, 2)
              pygame.draw.rect(tela, color2, input_box2, 2)
              pygame.draw.rect(tela, color3, input_box3, 2)  # Desenha a caixa de confirmação de senha
              pygame.draw.rect(tela, color_inactive, button_rect)
              
              fonte_h1_login = pygame.font.Font(None, 145)
              mensagem_boas_vindas = fonte_h1_login.render("Registrar", True, txt_color)
              
              tela.blit(return_image, (50, altura - return_image.get_height() - 750))
              tela.blit(mensagem_boas_vindas, (largura // 2 - mensagem_boas_vindas.get_width() // 2, altura // 8))
              texto_usuario = fonte.render("Usuário:", True, txt_color)
              tela.blit(texto_usuario, (input_box1.x, input_box1.y - 40))
              texto_senha = fonte.render("Senha:", True, txt_color)
              tela.blit(texto_senha, (input_box2.x, input_box2.y - 40))
              texto_confirmar_senha = fonte.render("Confirmar Senha:", True, txt_color)  # Texto para a confirmação de senha
              tela.blit(texto_confirmar_senha, (input_box3.x, input_box3.y - 40))
              tela.blit(fonte.render("Cadastrar", True, txt_color), (button_rect.x + 125, button_rect.y + 10))
              pygame.display.flip()
|-- src/
  |-- Images/
    |-- Bumbo.png
    |-- Bumbou.png
    |-- Caixa.png
    |-- Caixa2.png
    |-- Chimbal.png
    |-- Crash.png
    |-- tela inicial/
      |-- configuracoes_button.svg
      |-- drum_no_copyright.mp3
      |-- imagem_de_fundo.png
      |-- login_button.svg
      |-- logo.png
      |-- register_button.svg
      |-- return_button.png
      |-- sair_button.svg
      |-- tocar_button.svg
  |-- sounds/
    |-- Bumbo/
      |-- Bumbo v2.wav
      |-- Bumbo v3.wav
      |-- Bumbo.wav
    |-- Caixa/
      |-- Caixa v2.wav
      |-- Caixa v3.wav
      |-- Caixa.mp3
    |-- Caixa2/
      |-- Caixa2 v2.wav
      |-- Caixa2 v3.wav
      |-- Caixa2.mp3
    |-- Chimbal/
      |-- Chimbal v2.wav
      |-- Chimbal v3.wav
      |-- Chimbal.mp3
    |-- Crash/
      |-- Chash v3.wav
      |-- Crash v2.wav
      |-- Crash.mp3
    |-- Tutorial 1.wav
    |-- Tutorial 2.wav
|-- teste_cor_alvo_instrumentos.py
  Content:
    import cv2
    import numpy as np
    from batuque import pinkLower as initial_pinkLower, pinkUpper as initial_pinkUpper
    
    def nothing(x):
        pass
    
    cv2.namedWindow('Trackbars and Pink Color', cv2.WINDOW_NORMAL)
    
    # Cria trackbars para ajustar os valores HSV para rosa
    cv2.createTrackbar('Pink Hue Low', 'Trackbars and Pink Color', initial_pinkLower[0], 179, nothing)
    cv2.createTrackbar('Pink Hue High', 'Trackbars and Pink Color', initial_pinkUpper[0], 179, nothing)
    cv2.createTrackbar('Pink Sat Low', 'Trackbars and Pink Color', initial_pinkLower[1], 255, nothing)
    cv2.createTrackbar('Pink Sat High', 'Trackbars and Pink Color', initial_pinkUpper[1], 255, nothing)
    cv2.createTrackbar('Pink Val Low', 'Trackbars and Pink Color', initial_pinkLower[2], 255, nothing)
    cv2.createTrackbar('Pink Val High', 'Trackbars and Pink Color', initial_pinkUpper[2], 255, nothing)
    
    # Função para obter os valores dos trackbars
    def get_trackbar_values():
        pink_h_low = cv2.getTrackbarPos('Pink Hue Low', 'Trackbars and Pink Color')
        pink_h_high = cv2.getTrackbarPos('Pink Hue High', 'Trackbars and Pink Color')
        pink_s_low = cv2.getTrackbarPos('Pink Sat Low', 'Trackbars and Pink Color')
        pink_s_high = cv2.getTrackbarPos('Pink Sat High', 'Trackbars and Pink Color')
        pink_v_low = cv2.getTrackbarPos('Pink Val Low', 'Trackbars and Pink Color')
        pink_v_high = cv2.getTrackbarPos('Pink Val High', 'Trackbars and Pink Color')
    
        return (pink_h_low, pink_s_low, pink_v_low), (pink_h_high, pink_s_high, pink_v_high)
    
    # Função para converter valores HSV para BGR
    def hsv_to_bgr(hsv_color):
        hsv_color = np.uint8([[hsv_color]])
        bgr_color = cv2.cvtColor(hsv_color, cv2.COLOR_HSV2BGR)[0][0]
        return bgr_color
    
    # Função para criar um patch de cor
    def create_color_patch(color_lower, color_upper):
        color_patch = np.zeros((100, 300, 3), np.uint8)
        bgr_color_lower = hsv_to_bgr(color_lower)
        bgr_color_upper = hsv_to_bgr(color_upper)
        color_patch[:50] = bgr_color_lower
        color_patch[50:] = bgr_color_upper
        return color_patch
    
    # Função para detectar a cor rosa no frame
    def detect_color(frame, lower, upper):
        hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
        mask = cv2.inRange(hsv, lower, upper)
        result = cv2.bitwise_and(frame, frame, mask=mask)
        return result, mask
    
    camera = cv2.VideoCapture(0)
    
    while True:
        # Captura um frame da câmera
        ret, frame = camera.read()
        if not ret:
            break
    
        # Atualiza os valores HSV com base nos trackbars
        pinkLower, pinkUpper = get_trackbar_values()
    
        # Detecta a cor que queremos
        detected_color, mask = detect_color(frame, pinkLower, pinkUpper)
    
        # Cria o patch da cor
        color_patch_pink = create_color_patch(pinkLower, pinkUpper)
    
        cv2.imshow('Original Frame', frame)
        cv2.imshow('Detected Pink Color', detected_color)
        cv2.imshow('Trackbars and Pink Color', color_patch_pink)
    
        if cv2.waitKey(1) & 0xFF == ord('q'):
            break
    
    # Libera a câmera e fecha as janelas
    camera.release()
    cv2.destroyAllWindows()
